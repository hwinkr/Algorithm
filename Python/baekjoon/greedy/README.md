# BaekJoon Greedy


#####  문제를 해결할 때 현재 내가 처한 상황에서 가장 좋은 것을 선택
##### 일반적인 상황에서는 이 알고리즘 자체로 최적해 보장 X 
***

##### solved List
* [1541](https://www.acmicpc.net/problem/1541)
* [1931](https://www.acmicpc.net/problem/1931)
* [2839](https://www.acmicpc.net/problem/2839)
* [11047](https://www.acmicpc.net/problem/11047)
* [11399](https://www.acmicpc.net/problem/11399)
* [13305](https://www.acmicpc.net/problem/13305)
* [1049](https://www.acmicpc.net/problem/1049)
* [1439](https://www.acmicpc.net/problem/1439)
* [1744](https://www.acmicpc.net/problem/1744)
* [2437](https://www.acmicpc.net/problem/2437)
* [4796](https://www.acmicpc.net/problem/4796)
* [10610](https://www.acmicpc.net/problem/10610)
* [16953](https://www.acmicpc.net/problem/16953)


## check 
`1931`

진행할 수 있는 회의의 수 최댓값을 묻는 문제. <br /> 
최대한 많은 회의를 진행하려면 ? 빨리 시작하는 것 보다 빨리 끝나는 것이 회의를 수를 결정하는데 큰 영향을 끼침. 아무리 빨리 시작하더라도 회의 시간이 길어지면 기다려야 하는 회의도 많아짐
```
arr.sort(key=lambda  x:  x[0])
arr.sort(key=lambda  x:  x[1])
```
x[0] 도 sort를 하는 이유는 시작하자마자 끝나는 회의가 존재하기 때문.

`1946`

시간 많이씀..;
1931 과 유사한 문제. <br />
`<해결순서>`
1. 서류심사 순위가 높은 순대로 오름차순 정렬한다
2. 나보다 뒤에 있는 사람이 나를 탈락 시킬 수 없다, 둘 중 하나만 순위가 높으면 탈락하지 않는다
3. 내 앞에 있는 사람중 나보다 면접 순위가 높은 사람이 있으면 나는 탈락한다.
4. 합격한 사람이 추가 됐다는 것은 그 사람의 면접 순위가 현재 제일 높음을 의미한다.  
5. 모두 비교할 필요 없이 앞 사람 중 가장 면접 순위가 높은 사람이 나보다 낮으면 나는 탈락 하지 않는다.

```
for  i  in  range(1, len(lst)):
	if(lst[move_index][1]  >  lst[i][1]):
		pass_cnt  +=  1
		move_index  =  i
```

`1541`

`<해결순서>`
1. - , + 만 있는 식에서 값을 최소로 만들기 위해서는 빼는 숫자를 최대로 만들면 된다
2. 문자열을 '-' 기준으로 split 하면 묶어야할 숫자와 + 가 배열 한칸을 차지한다
3. 그 문자열을 다시 '+' 기준으로 split 하여 각 요소들을 더해준다

```
x = input().split()
```

`1744`

현재 나에게 매우 어려운 문제였다,,,, 문제를 이해하는것에도 시간이 꽤 걸렸고 , 코드 구현에서 상당히 애먹다가 힌트를 봐버린 문제,,
이런 문제들을 만날때마다 알고리즘 문제는 단순히 코드를 잘 짜고 라이브러리 함수를 잘 알고 있는 것 보다 문제해결 사고력이 더 중요한것 같다는걸 느낌

`<핵심>`

|숫자|숫자|수식|
|--|--|--|
|양수(>1)|양수(>1)|x
|음수(<=-1)|음수(<=-1)|x
|양수(>1)|1|+
|음수(<=-1)|1|+
|양수(>1)|0|+
|음수(<=-1)|0|x

`<해결순서>`
1. 1 , 0 을 만났을 경우 어떻게 처리하는지를 이해해야 한다
2. 1보다 큰 정수 리스트 , 1 리스트 , 0 과 음수 리스트 3개를 만든다
3. 양수는 오름차순 , 음수는 내림차순 정렬
4. 리스트 원소의 갯수가 짝수면 2개씩 곱해서 더하고 , 홀수면 2개씩 곱해서 더하고 마지막 원소를 따로 더한다
5. 어떤 경우는 1은 그냥 + 이기 때문에 계산하고 나온 결과에 1의 갯수만큼 더해주면 최대가 된다

`2437`

코드는 전혀 복잡하지 않으나 최적해를 찾는 계산원리를 이해하는 것이 상당해 오래 걸렸다

`<해결순서>`
1. 오름차순 정렬한다. 
2. 현재까지 사용할 수 있는 추들로 만들수 있는 무게의 최댓값 + 1 을 다음 추를 사용하여 만들수 있는지 없는지 판단
3. 만들수 있다면 최댓값 + 다음추의 무게 , 여기서 중요한것은 다음추를 포함시키면 1 부터 최댓값 + 다음추의 무게 까지 모든 무게를 만들수 있다는 것. 이것이 문제를 푸는 핵심 키워드가 아니였나 싶다.
4. 만들수 없다면 최댓값 + 1 이 만들수 없는 최솟값이 된다
5. 모든 추의 무게들이 1보다 크다면 만들수 없는 무게의 최솟값은 그냥 1이다.

`ex) 1 1 2 7 -> 최댓값 : (1 + 1 + 2)  , 4 + 1 < 7 이므로 만들수 없는 최솟값은 5 `


`느낀점 , 앞으로의 greedy 학습 방향`

몇 문제 풀어보지 않았지만 , 여기까지 하면서 느낀점은 본격적으로 비교나 최솟값을 찾기 위한 반복문에 들어가기 전에 최대한 루프의 횟수를 줄이기 위한 노력을 해야지 시간초과가 나지 않는다는 것. 현재 상황에서 어떻게 해야 최소한의 비교로 최대한의 결과를 도출할 수 있는지 생각 하자.
