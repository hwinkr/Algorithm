# BaekJoon Graph Search

##### 알고리즘에서 그래프를 탐색하는 방법으로 크게 dfs , bfs 두 가지로 나뉜다.
`dfs`
##### 조건에 맞는 그래프의 노드를 탐색할 수 있을때까지   최대한 탐색한 후 , 다음 노드에 대해서 같은 작업을 반복 하는 것.
`bfs`
##### 임의의 노드와 인접한 노드를 모두 탐색한 후 , 다음 노드로 탐색을 넓혀 가는 것

##### solved List 
* [1012](https://www.acmicpc.net/problem/1012)
* [11724](https://www.acmicpc.net/problem/11724)
* [1260](https://www.acmicpc.net/problem/1260)
* [1525](https://www.acmicpc.net/problem/1525)
* [1697](https://www.acmicpc.net/problem/1697)
* [2178](https://www.acmicpc.net/problem/2178)
* [2468](https://www.acmicpc.net/problem/2468)
* [2606](https://www.acmicpc.net/problem/2606)
* [2644](https://www.acmicpc.net/problem/2644)
* [2667](https://www.acmicpc.net/problem/2667)
* [7562](https://www.acmicpc.net/problem/7562)
* [7576](https://www.acmicpc.net/problem/7576)


## check

`1697`
문제의 조건을 잘 읽어야 했다.. 
시간이 좀 걸렸는데, 그 이유는 가능한 위치의 범위에 대해서 제대로 읽지 않았고, 방문한 자리를 또 que에 추가하는 바람에 시간초과를 발생 시켰다. 문제에 입력값의 범위를 준다면 꼭 체크하고 넘어가야겠다...

추가로 `dist` 배열을 사용해서 방문했는지 판단할 수 있고 추가로 그 배열에 몇초가 걸리는지에 대해 함께 기록할 수 있어서 따로 visited 배열을 만들 필요가 없어 메모리를 더 효율적으로 사용 할 수 있다는 것을 알았다!

```
for  nx  in (x  -  1, x  +  1, x  *  2):
if  0  <=  nx  <=  MAX  and  not  dist[nx]:
dist[nx]  =  dist[x]  +  1
que.append(nx)
```
`2468`
풀었는데,, 자꾸 런타임에러가 나서 구글링 해보니 비가 오지 않는 경우도 추가해줘야 한다고 해서 원래 `for  i  in  range(1, max_height):`  로 탐색 했었는데 `for  i  in  range(max_height):` 로 바꾸니 맞았다..
이 조건이 페이지 맨 아래의 노트에 적혀있어서 보지 못했다,, 좀 킹받는다
잠기지 않는 영역의 최대 갯수를 출력해야 하므로 그냥 최소 높이부터 최대 높이까지 모든 경우에서의 그래프 탐색을 하면 된다. 
추가로 백준은 재귀함수 제한은 자동으로 10000 이기 때문에 시간초과 , 런타임에러를 발생 시키지 않으려면 `sys.setrecursionlimit(100000)` 을 추가 해줘야한다.
`7576`
골드 5 문제라서 쫄고 시작한 문제,, 근데 내 생각대로 풀었는데 시도 한번에 맞았습니다가 떠서 엥..? 했던 문제. 하지만 시간은 많이 걸림...!!
`<해결순서>`
1.  bfs 함수에 들어가기 전에 농장에서 익은 토마토가 위치한 좌표를 que 에 추가한다.
2.  0번째 날에서 1번째 날로 넘어가는 경우를 생각해보면 농장에는 익은 토마토의 갯수가 1개 이상인 경우가 있다.
3. 그 토마토에 의해 인접 토마토가 모두 익게된 이후에 day+=1 을 해준다
```
day  =  0
size  =  len(que)
cnt  =  0
if(cnt  ==  size):
	day  +=  1
	size  +=  len(que)
```
4. 0번째 날 기준,  농장에서 익은 토마토의 갯수가 2이다. 그러면 `size = 2` 로 출발 
5. 하나의 토마토에 대해서 탐색을 진행할 때마다 `cnt += 1`을 해주고 `cnt == size`라면 하루에 탐색할수 있는 토마토를 모두 탐색한 것. 따라서 , day += 1
6. 0번째 날에 익은 토마토의 갯수가 3개라면 `size += len(que) -> 5`    이것을 반복한다.

`1525`
지금까지 파이썬으로 문제를 풀어나가면서 이 문제보다 파이썬의 장점을 잘 보여주는 문제는 없었던 듯.. 더 풀면 또 다른 문제에서 이걸 느낄수 있겠지만.. 
이 문제는 시간도 많이 걸렸고, 자료구조의 힘을 느낄 수 있던 문제였다.
메모리 제한도 평소 풀던 문제의 1/4라서 최대한 중복을 피하면서 탐색을 해야 함을 알수 있다.
`<틀린 해결순서>`
1.  0의 상하좌우에 원래 0 자리에 있어야할 숫자가 있는 경우에만 탐색을 진행한다..
2. 근데 여기서 부터 이미 틀린게  무수한 반례가 존재함..
3. 이 로직을 구현한다고 시간을 썼지만 ,, 결과는 틀렸습니다.. 탐색 할 수 있는 노드들을 탐색 못하게 하기 때문

여기서 파이썬의 힘이 등장함
2차원 배열의 각 원소들을 하나의 문자열에 저장한 후 , 그 문자열을 set 에 저장해서 중복 불가능 하게 한다. 추가 하는 경우에도 현재 만든 문자열이 set에 존재하지 않으면 추가 하는 방식으로 코드를 짠다. 
```
str  =  ''
for  _  in  range(3):
	str  +=  ''.join(list(input().split()))
```
list , set 형태의 변환이 굉장히 쉽기 때문에 활용만 잘하면 깔끔하게 문제를 풀수있다...
사실 힌트봄 ㅋㅋ..;;


`느낀점 , 앞으로의 graph search 학습 방향`

일단 문제를 이해한 후 , 이 문제는 dfs , bfs 중 어느 방법을 사용해야 더 효율적으로 문제를 해결할 수 있을지 판단 하는 것이 중요하다.  dfs 를 사용하면 재귀적으로 코드를 짜야하는데 재귀를 종료해야하는 조건에서 return문을 작성하는것이 좀 까다로워서 대부분의 문제를 bfs로 풀려고 하는 경향이 있었던것 같다. 하지만, 모든 문제가 bfs를 사용하는 것이 효율적인 것이 아니므로 재귀함수의 종료와 그 시점에 return문 작성에 대해서 정확히 짚고 넘어가야한다!!
