```py
def solution(n):
    answer = []

    def hanoi(n: int, start: int, end: int, mid: int) -> None:
        if n == 1:
            answer.append([start, end])
            return

        hanoi(n - 1, start, mid, end)
        answer.append([start, end])
        hanoi(n - 1, mid, end, start)

    hanoi(n, 1, 3, 2)
    return answer
```

### 📌 풀이

처음에는 문제를 해결할 아이디어를 떠올리지 못하다가 규칙을 통해서 `재귀`적으로 해결할 수 있다고 판단했다.

n이 3인 경우, 3번 기둥으로 이동 시키는 방법

1. 3번 원판을 제외한, 2개의 원판을 2번 기둥으로 이동 시킨다.
2. 3번 원판을 3번 기둥으로 이동 시키고 2개의 원판을 3번으로 이동 시킨다.

이를 일반화 해보면 다음과 같다.

1. n번 원판을 제외한, n - 1개의 원판을 2번 기둥으로 이동 시킨다.
2. n번 원판을 3번 기둥으로 이동 시키고 n - 1개의 원판을 3번으로 이동 시킨다.

n - 1개의 원판을 2번 기둥으로 이동 시키는 방법은 다음과 같다.

1. n - 1번 원판을 제외한 n - 2개의 원판을 3번 기둥으로 이동 시킨다.
2. n - 2번 원판을 2번 기둥으로 이동 시키고, n - 2개의 원판을 2번으로 이동 시킨다.

n -2개의 원판을 3번 기둥으로 이동 시키는 방법은, 다시 n - 2 원판을 제외한 n- 3개의 원판을 2로 이동 시키고 n - 2 원판을 3으로 이동 시키고, n - 3개의 원판을 다시 3으로 이동 시킨다…  
n이 1 즉, 제일 위에 있는 원판이 될 때 까지 **이 방법들이 계속해서 반복 되기 때문에 매개변수만 달라지고 하는 일은 같은 함수** `hanoi`를 재귀적으로 호출함으로서 문제를 해결할 수 있다.
