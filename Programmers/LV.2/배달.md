```py
import heapq

def count(dist:list, k:int) -> int:
    return sum([1 for d in dist if d <= k])

def dijkstra(n:int, k:int, graph:list, start:int, max_dist:int) -> int:
    dist = [max_dist for _ in range(n + 1)]
    dist[start] = 0

    heap = []
    heapq.heappush(heap, (0, start))

    while heap:
        weight, node = heapq.heappop(heap)

        for next_node, next_weight in graph[node]:
            if dist[next_node] > weight + next_weight:
                dist[next_node] = weight + next_weight
                heapq.heappush(heap, (dist[next_node], next_node))

    return count(dist, k)

def solution(N, road, K):
    max_dist = 50 * 10000 + 1
    graph = [[] for _ in range(N + 1)]

    for a, b, weight in road:
        graph[a].append((b, weight))
        graph[b].append((a, weight))

    return dijkstra(N, K, graph, 1, max_dist)
```

### ğŸ“Œ í’€ì´

ì´ ë¬¸ì œëŠ” **ë‹¤ìµìŠ¤íŠ¸ë¼** ì•Œê³ ë¦¬ì¦˜ì— ëŒ€í•´ì„œ ì•Œê³  ìˆìœ¼ë©´ ì‰½ê²Œ í•´ê²°í•  ìˆ˜ ìˆë‹¤.  
ë‹¤ìµìŠ¤íŠ¸ë¼ ì•Œê³ ë¦¬ì¦˜ì€ ê¸°ë³¸ì ìœ¼ë¡œ ë‹¨ë°©í–¥ ê·¸ë˜í”„ë¥¼ ì‚¬ìš©í•˜ì§€ë§Œ, ì´ ë¬¸ì œëŠ” ì–‘ë°©í–¥ ê·¸ë˜í”„ë¥¼ ì‚¬ìš©í•œë‹¤.  
ì–‘ë°©í–¥ ê·¸ë˜í”„ë¥¼ ì‚¬ìš©í•œë‹¤ í•˜ë”ë¼ë„ ì•Œê³ ë¦¬ì¦˜ì€ ë‹¬ë¼ì§€ì§€ ì•ŠëŠ”ë‹¤.
