```py
def solution(n):
    answer = 1  # 자신을 더하면 연속한 숫자가 되기 때문에 1부터 시작

    for i in range(1, n // 2 + 2):
        tmp = i
        for j in range(i + 1, n // 2 + 2):
            tmp += j

            if tmp == n:
                answer += 1
                break
            elif tmp > n:
                break

    return answer
```

`n ≤ 10,000` 이하 이기 때문에 시간복잡도가 O(n^2)인 풀이로 해결해도 시간초과가 발생하지 않을 것으로 판단했다.

n 이 연속된 숫자의 합으로 만들어지면 되기 때문에, 반복문 2개를 통해서 해결했다.

시간복잡도를 줄이기 위해서 `n// 2 + 1` 까지만 반복문을 돌게 했는데, 그 이유는 문제의 예시를 통해서 알 수 있다.

**예) 7 + 8 = 15**

가령, i 가 8인 경우 8보다 크면서 연속된 숫자로 15를 만들 수 있는 방법은 없고 작은 숫자인 7을 통해서(8 + 7 =15) 15를 만들 수 있지만 이 경우는 이미 카운트 했기 때문에 n//2 + 1 까지만 반복해서 시간복잡도를 줄이는 방법을 사용했다.
