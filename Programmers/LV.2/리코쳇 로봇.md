# ë¦¬ì½”ì³‡ ë¡œë´‡

```python
from collections import deque

DIRECTION = [(-1, 0), (0, 1), (1, 0), (0, -1)]


def movable(board: list, x: int, y: int) -> bool:
    return 0 <= x < len(board) and 0 <= y < len(board[0]) and board[x][y] != "D"


def bfs(board: list, visited: list, que: deque, dest_x: int, dest_y: int) -> int:
    while que:
        x, y, cnt = que.popleft()

        if x == dest_x and y == dest_y:
            return cnt

        for (dx, dy) in DIRECTION:
            nx = x + dx
            ny = y + dy
            while movable(board, nx, ny):
                nx += dx
                ny += dy
            nx -= dx
            ny -= dy

            if not visited[nx][ny]:
                visited[nx][ny] = True
                que.append((nx, ny, cnt + 1))

    return -1


def find(board: list, target: str) -> list:
    for i in range(len(board)):
        for j in range(len(board[0])):
            if board[i][j] == target:
                return [i, j]


def solution(board):
    row, col = len(board), len(board[0])
    start_x, start_y = find(board, "R")
    dest_x, dest_y = find(board, "G")
    visited = [[False] * col for _ in range(row)]

    visited[start_x][start_y] = True
    que = deque([(start_x, start_y, 0)])

    return bfs(board, visited, que, dest_x, dest_y)
```

### ğŸ“Œ í’€ì´

ë¬¸ì œì™€ ì˜ˆì œ ì„¤ëª…ì„ ì£¼ì˜ê¹Šê²Œ ì½ì–´ë´ì•¼ í•©ë‹ˆë‹¤.  
`G` ë¥¼ ë§Œë‚˜ê²Œ ë˜ëŠ” ê²½ë¡œë¡œ ë¯¸ë„ëŸ¬ ì§€ëŠ” ê²½ìš°ì— ë§Œì•½ `G` ë’¤ì— ë²½ì´ ì—†ê±°ë‚˜ ì¥ì• ë¬¼ì´ ì—†ëŠ” ê²½ìš° ì¦‰, ë” ë¯¸ë„ëŸ¬ì§ˆ ìˆ˜ ìˆëŠ” ê²½ìš°ì—ëŠ” ëª©í‘œì§€ì ì— ë„ì°©í•˜ë”ë¼ë„ ê³„ì† ë¯¸ë„ëŸ¬ì§‘ë‹ˆë‹¤.  
ëª©í‘œì§€ì ì— ë„ì°©í•  ìˆ˜ ìˆëŠ” ì¡°ê±´ì€ í˜„ì¬ ìœ„ì¹˜ê°€ `G` ì´ê³  `G` ë’¤ì— ë²½ì´ë‚˜ ì¥ì• ë¬¼ì´ ìˆì–´ì„œ ë”ì´ìƒ ë¯¸ë„ëŸ¬ ì§ˆ ìˆ˜ ì—†ëŠ” ê²½ìš° ì…ë‹ˆë‹¤.  
ì´ê²ƒë§Œ ìœ ì˜ í•œë‹¤ë©´ ë‚˜ë¨¸ì§€ëŠ” ê¸°ë³¸ì ì¸ bfs ë¬¸ì œì™€ ìœ ì‚¬í•©ë‹ˆë‹¤.
